# 母函数

> 母函数即生成函数，是组合数学中尤其是计数方面的一个重要理论和工具。

## 什么是母函数

> 就是把一个已知的序列和 x 的多项式合并起来，新产生的多项式就叫原来序列的母函数

至于怎么合并，看这个例子

序列{0, 1，2，3，4，5...n}的母函数就是`f(x)=0+x+2x^2+3x^3+4x^4+...+nx^n`（这个 x 没有任何意义，应该说，你不需要把它当做一个函数，你只要知道母函数这么写就可以了）

序列{1,1,1,1,1......}的母函数就是

`f(x)=1+x + x^2+x^3+x^4....`

二项式展开的序列比如这个{1,4,6,4,1,0,0,0,0,0.....}是 C(4,0)到 C(4,4)的系数，那它的母函数就是

`f(x)=1+4x+6x^2+4x^3+1x^4`

母函数就长这样，对正常人来讲，这种东西毫无意义

那看点有意义的东西

有 1 克、2 克、3 克、4 克的砝码各一枚，能称出哪几种重量？每种重量各有几种可能方案？

假如 x 的幂次数表示几克的砝码

那么

- 1 克的砝码表示为 `1+x^1`
- 2 克的砝码表示为 `1+x^2`
- 3 克的砝码表示为 `1+x^3`
- 4 克的砝码表示为 `1+x^4`

每个砝码都可以选择取或不取,所以这里的 1 可以认为 `1*x^0`，表示不取这颗砝码

那么把这些乘起来

`(1+x^1)(1+x^2)(1+x^3)(1+x^4)`=`1+(x^1)+(x^2)+2(x^3)+2(x^4)+2(x^5)+2(x^6)+2(x^7)+(x^8)+(x^9)+(x^10)`

根据指数来看，我们可以称出 0~10 这么多的重量，其中 3~7 的系数为 2，说明有 2 种称的方法

那么我们来细看一遍

0. 0(什么砝码都不放).................（1 种）
1. 1.............................................（1 种）
2. 2.............................................（1 种）
3. 3 或 1+2..................................（2 种）
4. 4 或 1+3..................................（2 种）
5. 1+4 或 2+3..............................（2 种）
6. 2+4 或 1+2+3..........................（2 种）
7. 3+4 或 1+2+4..........................（2 种）
8. 1+3+4......................................（1 种）
9. 2+3+4......................................（1 种）
10. 1+2+3+4..................................（1 种）

所以说母函数在 ACM 就是这么用的，跟函数没关系，跟写法有关系。。。

```
求用 1 分、2 分、3 分的邮票贴出不同数值的方案数：（每张邮票的数量是无限的）
```

- 1 分`(1+x^1+x^2+x^3+x^4+......)`
- 2 分`(1+x^2+x^4+x^6+x^8+......)`
- 3 分`(1+x^3+x^6+x^9+x^12+......)`

然后这 3 个乘起来（让电脑去乘吧）

对于这种无限的，题目肯定会给你他询问的数值的范围，计算到最大的范围就可以了

```cpp
#include <cstdio>

const int N = 100 + 5;   //假如题目只问到 100 为止
const int MAX = 3;       //题目只有 1,2,3 这 3 种邮票
long long c1[N], c2[N];  //c2 是临时合并的多项式，c1 是最终合并的多项式
int n;

void init() {
    c1[0] = 1;                                 //一开始 0 的情况算一种
    for (int i = 1; i <= MAX; i++) {           //把 1 分到 MAXN 的邮票合并，变成一个多项式
        for (int j = 0; j < N; j += i) {       //i 分的邮票，步长是 i
            for (int k = 0; j + k < N; k++) {  //从 x^0 到 x^N 遍历一遍
                c2[j + k] += c1[k];            //因为 j 的所有项系数为 1，所以 c1[k]可以看成 c1[k]\*1;
            }
        }
        for (int j = 0; j < N; j++) {  //把 c2 的数据抄到 c1，清空 c2
            c1[j] = c2[j];
            c2[j] = 0;
        }
    }
}

int main() {
    init();
    while (scanf("%d", &n) != EOF) {
        printf("%I64d\n", c1[n]);
    }
}
```

### MORE

- hdu 1028
  - http://acm.hdu.edu.cn/showproblem.php?pid=1028

```
题目问一个数字 n 能够拆成多少种数字的和
比如 n=4

4 = 4;
4 = 3 + 1;
4 = 2 + 2;
4 = 2 + 1 + 1;
4 = 1 + 1 + 1 + 1;

有 5 种，那么答案就是 5
```

- hdu 1398
  - http://acm.hdu.edu.cn/showproblem.php?pid=1398

```
题目说一个国家的硬币都是方形的，面值也是方形的
有 1 块钱，4 块钱，9 块钱，16 块钱......一直到 289 块钱（17^2）
问想组成 n 块钱有几种方法
```

- hdu 1085
  - http://acm.hdu.edu.cn/showproblem.php?pid=1085

母函数在数学上真的用处很大，但是我没怎么看到在 ACM 上有什么太大的用处（可能我做的题还不够多 T_T）

比如刚刚上面的 3 个例题，都有更快的做法

- 第一题：动态规划，时间复杂度 O(n^2)
- 第二题：动态规划，时间复杂度 O(n^2)
- 第三题：≖‿≖✧ 特判就好了，时间复杂度 O(1)

哈哈哈有没有被骗的感觉，有些题目，不要陷进算法里，这题 O(1)的复杂度就可以了，如果你用三个 for 循环，那就太慢了，而且数量不同，还没有办法预处理，如果数据量大，肯定超时

所以，母函数我们只要理解原理就好了

那么 ACM 的母函数讲完了(\*°∀°)

**以上内容来源于** [https://www.cnblogs.com/linyujun/p/5207730.html](https://www.cnblogs.com/linyujun/p/5207730.html)
