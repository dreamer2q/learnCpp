# BFS

搜索算法，如何进行遍历

## 核心(状态的转移)

- 如何将问题进行抽象，即使得计算机可以进行处理
- 如何定义状态
- **如何进行状态转移**
- 判断是否到底最终状态

为了描述一个状态，我们可能需要进行结构体定义，用来描述表示这些状态

例如

```cpp
struct {
    Count steps;  //表示当前的步数，每走一次，步数加一
    State state;  //表示当前的状态，可以和最终状态比较，用以判断搜索是否结束
};
```

### 状态的转移

如果，对于每一个状态，都有两种不同的下一个可转移的状态与之对应，那么对于所有的状态转移，可以构成一个`二叉树`

我们只需要对这个`二叉树`进行层次遍历即可，因为，每一层对应一个步数，而我们需要找到最短路径。

遍历伪代码

```cpp
Status bfs(State start, State end, BTree tree){
    queue<State> q;
    q.push(start); //初始化队列
    while(q 非空){
        auto curr = q.frontAndPop(); //获取队列的一个元素，并且出队
        if( curr == end ){   // 若到达最终状态，返回
            return curr;
        }

        //若有左儿子, 则加入队列
        if(curr.hasLeft()){
            q.push(curr.left);
        }
        //对右儿子进行同样的操作
    }
}
```

可以容易看到，遍历的核心转移在于这个先进先出的队列。
通过这个队列，我们将同时扮演消费者和生产者的角色。

生产者负责产生新状态，消费者自然负责消费这些状态。
而这个先进先出的特性保证了状态深度是一步一步增加的，这样就实验了数的层次遍历。

当然，处理遍历树，还可以遍历图等。

### 状态的剪裁

对于有些状态的转移，可能会出现这样的情况，即下一个状态可能会产生上一个状态。

这个时候，如果不加处理，就会产生死循环，在遍历中迷失了方向。

这个时候，就需要对每一个状态增加一个`是否遍历过`的状态量。

对于，已经遍历过的状态，直接跳过，也就是所谓的剪枝操作。

这个操作对于深度搜索非常重要，因为深度的增加带来的计算量可能是指数级的增加。

### 状态的产生

对于一个状态可能会产生许多子状态的问题来说，非常有必要进行一下偷懒。

比如说，对于象棋中的马，每一步最多又8种状态，也就是说每走一步最多有八种可能性，

如果单纯的使用`if`来判断每一种状态，虽然可行，但是会有大量的重复代码。

这个时候可以通过一个`dirs`的数组，来储存所有可以走的方向，产生子状态的时候，只需要遍历这个数组即可。
