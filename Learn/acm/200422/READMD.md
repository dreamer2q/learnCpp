# 搜索

> 在我们遇到的一些问题当中，有些问题我们不能够确切的找出数学模型，即找不出一种直接求解的方法，解决这一类问题，我们一般采用搜索的方法解决。搜索就是用问题的所有可能去试探，按照一定的顺序、规则，不断去试探，直到找到问题的解，试完了也没有找到解，那就是无解，试探时一定要试探完所有的情况（实际上就是穷举）

- 对于问题的第一个状态，叫初始状态，要求的状态叫目标状态。
- 搜索就是把规则应用于实始状态，在其产生的状态中，直到得到一个目标状态为止。
- 产生新的状态的过程叫扩展（由一个状态，应用规则，产生新状态的过程）

**要点**

- （1）初始状态
- （2）重复产生新状态
- （3）检查新状态是否为目标，是结束，否转（2）

**区分**

- 如果搜索是以接近起始状态的程序依次扩展状态的，叫宽度优先搜索。
- 如果扩展是首先扩展新产生的状态，则叫深度优先搜索。

## 深度搜索优先(DFS)

> 深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。

**思路**

深度优先搜索用一个数组存放产生的所有状态。

- （1） 把初始状态放入数组中，设为当前状态；
- （2） 扩展当前的状态，产生一个新的状态放入数组中，同时把新产生的状态设为当前状态；
- （3） 判断当前状态是否和前面的重复，如果重复则回到上一个状态，产生它的另一状态；
- （4） 判断当前状态是否为目标状态，如果是目标，则找到一个解答，结束算法。
- （5） 如果数组为空，说明无解。

**伪代码**

1.  首先将根节点放入`stack`中。

2.  从`stack`中取出第一个节点，并检验它是否为目标。

    - 如果找到目标，则结束搜寻并回传结果。
    - 否则将它**某一个**尚未检验过的直接`子节点`加入`stack`中。

3.  重复步骤 2。
4.  如果不存在未检测过的直接子节点。

    - 将上一级节点加入`stack`中。
    - 重复步骤 2。

5.  重复步骤 4。

    - 若`stack`为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。

**示例**

- 输入一个正整数 n,请按照字典序输出 1-n 的全排列，每个排列输出一行，每个数字后面跟一个空格

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int num[10],vis[10];
void dfs(int step);

int main(){
     while(scanf("%d",&n)==1){
	    memset(vis,0,sizeof(vis));
	    dfs(1);
     }
     return 0;
}

void dfs(int step){ //思考：参数step的含义是？
        if(step == n+1){
               for(int i = 1; i <= n; i++)
                        printf("%d ", num[i]);
                printf("\n");
                return;
        }
        for(int i = 1; i <= n; i++){
                if(vis[i] == 0){
                        num[step] = i;
                        vis[i] = 1;
                        dfs(step+1);
                        // 思考：下面一句如果注销会是什么结果？
                        vis[i] = 0; //回溯，难点
                }
        }
}
//思考：如果是求任意n个数的全排列，怎么办？
```

## 应用

```C
//todo
```
