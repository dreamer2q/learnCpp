# 基于 UDP 协议的聊天室

聊天室的一个核心在于如何进行消息的分发, 常见的方案有两种:

1. 服务端推送, 消息订阅。
2. 客户端轮询, 消息查询。

其中第一种方案对 UDP 这种无连接的协议不是很友好, 因为服务端下发需要类似 TCP 这种可靠连接的机制来保证下发数据的有效性。
第二种方案，对服务端的压力比较小，服务端只需要对外提供类似 RPC 的调用服务, 其复杂的状态管理交给客户端本地来维护即可。
这样服务端不需要单独维护每个用户的消息状态了, 让它本地自己维护就行了, 甚至能起到类似“心跳包”的机制, 检测客户端是否离线。

## Chat Server

1. 服务端维护一个客户端链表, 收到"加入聊天室"报文时, 建立相关的用户数据并保存到链表, 然后给用户颁发凭据(简单鉴别是否授权)。
2. 服务端维护一个消息链表, 收到客户端发来的"新聊天消息"报文时, 只需要维护好这份消息链表即可, 无需额外的消息分发操作。
3. 收到“拉去消息内容”的请求时候, 返回客户端查询的消息内容, 如果没有新消息可以简单返回空内容, 代表暂无消息; 同时更新用户上次活跃时间, 可以认为操作 5 分钟没有活跃的用户, 属于离线用户, 将其从客户端链表剔除。

## Chat Client

1. 客户端向服务端发起"加入聊天室"的数据报, 得到服务端的凭据后正式进入聊天室(假装建立了连接)。
2. 客户端本地维护一个消息链表, 每间隔 1s 就向服务端拉取一次指定编号之后消息记录(每个消息都有编号，从 0 开始, -1 代表从头开始拉去消息)。
3. 拉取到消息后进入本地维护的消息链表中(如果要针对之前的消息进行修改怎么办?可以弄一条修改消息的消息), 如果连续 30s 都没有成功得到反馈, 认为客户端离线(或者服务器掉线)。
4. 消息的发送伴随着消息拉取的请求, 消息发送给服务端然后拉取最新消息, 如果没有拉取到说明消息发送失败, 本地也不会显示出消息内容(就好像消息凭空消失了,虽然体验不太好,但是可以确保显示出来的消息都是发送成功的)。

# 数据结构体

## 数据流

如何传输一个不定长度的结构体数据呢? 由于数据的传输协议是 UDP, 且 UDP 无连接状态, 可以类比于 HTTP 服务器。

UDP 的一次发送与接受相当于完成了一次 HTTP 的请求, 因此我们的聊天协议也是基于这个思想来实现的:

首先我们需要一个通用的数据协议包, 来承载我们的流量:

```cpp
struct chat_package {
  uint16_t proto;    // 协议头 固定为 0xF0F1
  uint16_t size;     // 包大小 承载的数据大小(不包括头长度)
  uint8_t type;      // 数据类型(承载的数据结构类型)
  uint8_t checksum;  // 头校验和[假装有, 但实际并没有实现]
};
```

如上结构体可以看成是我们的头数据, 占用固定长度: 6 字节.

实际编码中只需要关注: `type` 即可。(甚至 `size` 都不需要关注, 这是因为我们知道`type`之后就知道接下来的数据结构了, 基本上都是定长的数据, `size`唯一有用的可能就是检查数据包是否完整了).

## 用户加入

接下来看下入户加入聊天室的流程:

1. 用户发送 `req_join_user` 请求, 携带自定义的用户名。
2. 服务器返回给用户分配的 `uid` 以及 `flag`, `last_msg_id` 等相关信息。

非常的简陋, 没有做用户重名的限制(可以轻易伪造别人的发言), 也没有任何机制保障用户的聊天记录安全, 因为任何人可以轻易拿到聊天室的聊天记录。

```cpp
// type 1
struct req_join_user {
  uname_t name;
};

// type 101
struct res_join_user {
  uint8_t flag;          // 0x01 表示OK
  uint32_t last_msg_id;  // 最新一条消息的 ID
  uint16_t uid;          // 分配的 ID
  time_t join_time;      // 进入时间
};

struct req_get_user {
  uint16_t uid;  // 用户 ID
};
```

其中`req_get_user`类型是用于其它用户通过 `uid` 来获取用户的信息, 表现为聊天的内容要显示用户的昵称。

上面一开始提及, 客户端也使用链表维护用户的信息, 实际编码的时候发现通过链表维护的信息查询效率比较低下, 通过用户信息属于读取比较重的操作。
因此实际的代码中, 将链表改成了数组, 同时确定了聊天室最大同时在线人数为`100`个, 因此只需要一个`100`大小的数组就行了。

## 消息发送与同步

客户端的消息全靠消息的`id`来进行维护:

1. 客户端通过 `last_msg_id+1` 来获取相对于客户端而言最新的一条消息(每秒一次)。
2. 服务端收到消息请求, 如果没有最新的消息则忽略客户端的请求(服务端可以通过此来判断客户端是否离线), 否则返回给客户端指定的消息。
3. 客户端收到下发的消息后, 更新聊天消息内容, 更新`last_msg_id`为最新的`id`(客户端消息链表需要根据`id`来排序)。

```cpp
// type 2
struct req_send_msg {
  uint16_t uid;      // 发送用户
  uint16_t msg_len;  // 消息长度
  const char* msg;   // 消息内容
};

// type 102
struct msg_t {
  uint32_t id;       // 消息 ID, 从 1 开始
  uint8_t mtype;     // 消息类型
  time_t mtime;      // 消息时间
  uint16_t uid;      // 用户 ID
  uint16_t msg_len;  // 消息长度
  const char* msg;   // 消息内容
};
```

这里需要注意一点的是, 消息下发时候只有 `uid` 因此客户端必须在拿到消息后选择一个时间点来更新内存中还不存在的 `uid` 记录。
更新一次之后, 后续就不需要再次更新 `uid` 的记录了, 除非用户离线了, 但是这里不考虑用户离线的情况, 因此可以看作 `uid` 是一次性的消耗品,
用完之后就不会再次分配到通用的`uid`了, 但是 `uid` 的总数又是有限的哈哈(因此这只是一个 demo)。

---

以上就是基于 UDP 聊天室的核心部分了(协议+数据), 虽然比较容易理解, 但是具体到编码其实还有许多的坑要踩的哈, 因为设计协议的时候没办法考虑到整个细节, 尤其是还是第一次做这样的事情。

虽然这里没有什么技术含量, 但是通过实践确实能学会很多东西, 尤其是工程相关的经验(坑)。

就比如说我一开始, 只是引入一个`头文件`, 然后`code runner`插件只能比较死板的执行`编译+运行`的简单动作, 我查看了一下文档也没有发现可以定制化的东西。(没有事正确的, 因为`code runner`仅针对简单的单文件代码, 而依赖于多个文件或者库的代码显然已经脱离了`code runner`的范畴了)。

为了解决手动编译麻烦的问题, 我简单尝试了`vscode`的`tasks`:

```json
{
  "tasks": [
    {
      "type": "cppbuild",
      "label": "C/C++: gcc build active file",
      "command": "gcc",
      "args": [
        "-fdiagnostics-color=always",
        "-g",
        "${file}",
        "-o",
        "${fileDirname}/${fileBasenameNoExtension}",
        "-I",
        "${workspaceFolder}",
        "-Wall"
      ],
      "options": {
        "cwd": "${fileDirname}"
      },
      "problemMatcher": ["$gcc"],
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "detail": "Task generated by Debugger."
    }
  ],
  "version": "2.0.0"
}
```

以上`task`编译参数中, 添加了`头文件`的路径, 这样我只需要 `command+shift+B` 就能完成编译的工作, 剩下就是到控制台简单执行一下进行一个调试或者验证。

之后, 出于界面的需要又引入了`ncurse`库, 编译的时候需要携带`-lncurses`参数。如果修改`tasks.json`添加相应的参数虽然能解决问题, 但是其它的文件不一定需要这个库, 因此这样的做法并不好。

这个时候我又想到了 `makefile` 构建文件了, 这个时候我才意识到 `makefile` 的好处, 之前其实对 `makefile` 挺反感的, 因为需要自己手动写一些东西, 又没有好的代码提示(过度依赖 IDE 补全的后果, 我承认过度依赖这个真的不好)。

然后我去网上搜索关于编写 `makefile` 的资料, 奇怪的事情发生了, `makefile` 的规则突然变得如此清晰明了。以前我看这些规则的时候, 总是没能`get`到点子上去, 让我一度非常抵制这个东西。

把别人写好的拿来, 简单修改后就能正常使用了, 只需要 `make` 一行指令就能完成服务端和客户端代码的构建工作, 效率提升了很多。

看来许多事情需要自己动手实践, 这样才能有更深入的理解, 以后也不会容易忘记。

# 客户端 UI

一个聊天室至少需要提供两块信息:

1. 输入框(发送用户消息)
2. 聊天框(查看聊天消息)

所以需要将控制台上下分成两块内容, 下方用于用户编辑输入, 上方用于消息展示。

于是理所当然的选择了 `ncurses` 用于控制台图形界面的编写。

## NCURSES

实现我们要的效果, 关键的一点是控制台的输入模式要变化:

```cpp
void init_screen() {
  setlocale(LC_ALL, "");
  main_win = initscr();
  if (main_win == NULL) {
    exit(-1);
  }

  noecho();
  cbreak();
  keypad(main_win, TRUE);
}
```

以上初始化控制台的模式/行为:

`noecho` 确保用户键入不会显示在控制台上, 自然 `printf` 相关的函数都没啥用处了。
`cbreak` 切换控制台的模式为 `raw` 模式, 但是会处理中断事件(例如 `ctrl+c` 终止事件)。如果是纯 `raw` 模式, 这些 `ctrl+c` 会作为输入内容交给程序处理。
所以一般而言, 如果不需要完全的接管控制台, 使用 `cbreak` 就能满足大部分场景了。

`keypad` 则是指定窗口接受特殊案件事件, 例如 `backspace` 正常行为是`删除`但这里直接作为一个普通键盘事件来处理了, 因此可以进行具体的定制化行为。

还有一种模式叫 `halfdelay`, 在这种模式下, 使用 `getch` 就不会死等用户输入了, 会尝试类似一个超时的事件, 表示用户在这个时间段没有任何输入操作。

一般情况下, 使用 `getch` 会阻塞程序, 如果想在等待输入事件的情况下, 去执行一个其它任务就需要单独创建一个线程/进程来完成, 而编写多线程程序的成本往往比单线程的成功高, 且容易出现副作用或者说 BUG。

```cpp
void init_window() {
  endwin();
  refresh();
  clear();

  int w = COLS;
  int chat_h = LINES * 0.8;
  int input_h = LINES * 0.2;

  chat_wbox = subwin(main_win, chat_h, w, 0, 0);
  chat_win = subwin(chat_wbox, chat_h - 2, w - 2, 1, 1);
  scrollok(chat_win, TRUE);
  box(chat_wbox, 0, 0);
  wrefresh(chat_wbox);
  wrefresh(chat_win);

  input_wbox = subwin(main_win, input_h, w, chat_h, 0);
  input_win = subwin(input_wbox, input_h - 2, w - 2, chat_h + 1, 1);
  box(input_wbox, 0, 0);
  wrefresh(input_wbox);
  wrefresh(input_win);
}
```

以上代码, 完成了控制台窗口的创建, 上半部分为聊天框, 占据整个控制台 `80%` 的高度, 其余部分则由输入框来充当.

这里麻烦的一点在于, 如果控制台的大小发生了改变, 那么里面显示的内容很可能会出现问题, 因此需要使用最新的大小进行一次重新的初始化(布局)。

重新初始化会导致之前的聊天内容丢失, 因此这里还需要恢复之前的聊天内容(内存中保持的数据派上用场了)。

# pthread 多线程协同工作

这里使用到多线程的原因在于, 聊天有许多代码是阻塞的, 如果让它一种阻塞在哪里, 会导致控制台无法处理用户的输入, 就如同控制台卡死了一样。

所以为了解决 `getch`, `sendto` 阻塞问题, 就自然而然的引入了 `pthread` 多线程库, 来帮我们完成具体的分工:

1. `pull handler` 用于从服务器拉去最新的消息内容, 然后显示上去。(消息同步, 间隔 1s)
2. `udp handler` 用于接受服务端返回的数据, 并进行相应的处理
3. `getch` 无输入时会阻塞线(ui 主线程, 也是 main 线程)

这样一个小小的客户端需要跑三个线程来完成, 而服务端居然只有单线程。

---

# 总结

一个简单的 UDP 聊天室, 思考了如下问题:

- UDP 的数据通讯(客户端在线状态思路)
- 使用 `ncurses` 构建控制台 UI
- `pthread` 的使用(不阻塞 UI)
- `getopt` 解析启动参数
- `struct list_head` 双向链表的使用
- `makefile` 的理解与适用
- `time` 日期事件的格式化

`UDP` 的使用相比于直接使用 `TCP` 是更简单快捷的, 这个好处是 `UDP` 无状态特性带来的, 只需要简单的使用 `sendto` 和 `recvfrom` 就能完成 `UDP` 数据的收发。

> [udp-chat-room](https://www.yuque.com/dreamer2q/learning/udp-chat-room)
