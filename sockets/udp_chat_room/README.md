# 基于 UDP 协议的聊天室

聊天室的一个核心在于如何进行消息的分发, 常见的方案有两种:

1. 服务端推送, 消息订阅。
2. 客户端轮询, 消息查询。

其中第一种方案对 UDP 这种无连接的协议不是很友好, 因为服务端下发需要类似 TCP 这种可靠连接的机制来保证下发数据的有效性。
第二种方案，对服务端的压力比较小，服务端只需要对外提供类似 RPC 的调用服务, 其复杂的状态管理交给客户端本地来维护即可。
这样服务端不需要单独维护每个用户的消息状态了, 让它本地自己维护就行了, 甚至能起到类似“心跳包”的机制, 检测客户端是否离线。

## Chat Server

1. 服务端维护一个客户端链表, 收到"加入聊天室"报文时, 建立相关的用户数据并保存到链表, 然后给用户颁发凭据(简单鉴别是否授权)。
2. 服务端维护一个消息链表, 收到客户端发来的"新聊天消息"报文时, 只需要维护好这份消息链表即可, 无需额外的消息分发操作。
3. 收到“拉去消息内容”的请求时候, 返回客户端查询的消息内容, 如果没有新消息可以简单返回空内容, 代表暂无消息; 同时更新用户上次活跃时间, 可以认为操作 5 分钟没有活跃的用户, 属于离线用户, 将其从客户端链表剔除。

## Chat Client

1. 客户端向服务端发起"加入聊天室"的数据报, 得到服务端的凭据后正式进入聊天室(假装建立了连接)。
2. 客户端本地维护一个消息链表, 每间隔 1s 就向服务端拉取一次指定编号之后消息记录(每个消息都有编号，从 0 开始, -1 代表从头开始拉去消息)。
3. 拉取到消息后进入本地维护的消息链表中(如果要针对之前的消息进行修改怎么办?可以弄一条修改消息的消息), 如果连续 30s 都没有成功得到反馈, 认为客户端离线(或者服务器掉线)。
4. 消息的发送伴随着消息拉取的请求, 消息发送给服务端然后拉取最新消息, 如果没有拉取到说明消息发送失败, 本地也不会显示出消息内容(就好像消息凭空消失了,虽然体验不太好,但是可以确保显示出来的消息都是发送成功的)。

# 数据结构体

```cpp
struct message {
    uint id;  // 消息 ID, 从 0 开始严格递增
    uint uid; // 用户 ID
    uint type; // 消息类型: 0 普通消息, 1
}
```

## 数据流

如何传输一个不定长度的结构体数据呢? 数据的传输协议

```c
0xF0F1 // 2Bytes 协议标识头
0x00FF // 2Bytes 结构体长度
```


